<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì ì‹¬ ë‚´ê¸° ì‚¬ë‹¤ë¦¬íƒ€ê¸°</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap');
        body { font-family: 'Noto Sans KR', sans-serif; }
        
        .ladder-scroll::-webkit-scrollbar { height: 8px; width: 8px; }
        .ladder-scroll::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 4px; }
        .ladder-scroll::-webkit-scrollbar-thumb { background: #c7c7c7; border-radius: 4px; }
        .ladder-scroll::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }

        canvas { cursor: pointer; }
        .input-group-move { animation: slideUp 0.3s ease-out; }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-amber-50 h-screen flex items-center justify-center p-4 overflow-hidden">

    <div class="bg-white w-full max-w-5xl rounded-2xl shadow-2xl overflow-hidden flex flex-col" style="height: 85vh;">
        
        <!-- Header -->
        <div class="bg-amber-500 p-4 flex justify-between items-center text-white shadow-md z-10 shrink-0">
            <h1 class="text-xl font-bold flex items-center gap-2">
                <i class="fa-solid fa-utensils"></i> ë¯¸ìŠ¤í„°ë¦¬ ì‚¬ë‹¤ë¦¬
            </h1>
            <button onclick="resetGame()" class="bg-amber-600 hover:bg-amber-700 text-xs px-3 py-1.5 rounded-lg transition">
                <i class="fa-solid fa-rotate-right mr-1"></i> ì²˜ìŒìœ¼ë¡œ
            </button>
        </div>

        <!-- Content Area -->
        <div class="flex-1 relative bg-white p-6 flex flex-col items-center justify-center overflow-hidden">
            
            <!-- Step 1: ì¸ì› ì„¤ì • -->
            <div id="step-1" class="w-full max-w-md text-center space-y-6">
                <div class="text-6xl text-amber-500 mb-4">
                    <i class="fa-solid fa-users-line"></i>
                </div>
                <h2 class="text-2xl font-bold text-gray-800">ì°¸ì—¬ ì¸ì›ì„ ì„ íƒí•˜ì„¸ìš”</h2>
                <p class="text-gray-500">ìµœëŒ€ 11ëª…ê¹Œì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤</p>
                
                <div class="flex items-center justify-center gap-4 my-6">
                    <button onclick="adjustCount(-1)" class="w-12 h-12 rounded-full bg-gray-100 hover:bg-gray-200 text-xl font-bold text-gray-600 transition">-</button>
                    <span id="player-count-display" class="text-4xl font-bold text-amber-600 w-16">4</span>
                    <button onclick="adjustCount(1)" class="w-12 h-12 rounded-full bg-gray-100 hover:bg-gray-200 text-xl font-bold text-gray-600 transition">+</button>
                </div>

                <button onclick="goToStep2()" class="w-full bg-amber-500 hover:bg-amber-600 text-white text-lg font-bold py-3 rounded-xl shadow-lg transition transform active:scale-95">
                    ë‹¤ìŒ ë‹¨ê³„ë¡œ <i class="fa-solid fa-arrow-right ml-2"></i>
                </button>
            </div>

            <!-- Step 2: ì´ë¦„ ì…ë ¥ (ê²°ê³¼ ì…ë ¥ ì‚­ì œë¨) -->
            <div id="step-2" class="hidden w-full h-full flex flex-col">
                <h2 class="text-xl font-bold text-gray-800 mb-2 text-center shrink-0">ì°¸ê°€ì ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”</h2>
                <p class="text-sm text-gray-500 text-center mb-4 shrink-0">ê²°ê³¼ëŠ” ìë™ìœ¼ë¡œ ëœë¤ ë°°ì¹˜ë©ë‹ˆë‹¤ (2ëª… ë‹¹ì²¨)</p>
                
                <!-- ì…ë ¥ í¼ -->
                <div class="flex-1 overflow-y-auto pr-2 mb-4 border-t border-b border-gray-100 py-4">
                    <div class="grid grid-cols-[40px_1fr] gap-2 items-center mb-2 text-xs text-gray-500 font-bold text-center px-4">
                        <span>ë²ˆí˜¸</span>
                        <span>ì°¸ê°€ì ì´ë¦„</span>
                    </div>
                    <div id="input-container" class="space-y-3 px-4">
                        <!-- JSë¡œ ìƒì„±ë¨ -->
                    </div>
                </div>

                <div class="flex gap-3 mt-auto shrink-0">
                    <button onclick="fillRandomNames()" class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold py-3 rounded-xl transition text-sm">
                        <i class="fa-solid fa-shuffle mr-1"></i> ëœë¤ ì´ë¦„ ì±„ìš°ê¸°
                    </button>
                    <button onclick="startGame()" class="flex-[2] bg-amber-500 hover:bg-amber-600 text-white font-bold py-3 rounded-xl shadow-lg transition transform active:scale-95 text-lg">
                        ì‚¬ë‹¤ë¦¬ ì‹œì‘! <i class="fa-solid fa-play ml-1"></i>
                    </button>
                </div>
            </div>

            <!-- Step 3: ê²Œì„ í™”ë©´ -->
            <div id="step-3" class="hidden w-full h-full flex flex-col relative">
                <div class="flex justify-between items-center mb-2 px-2 shrink-0">
                    <p class="text-sm text-gray-500"><i class="fa-solid fa-circle-info mr-1"></i>ì´ë¦„ì„ í´ë¦­í•˜ë©´ ê²°ê³¼ê°€ ê³µê°œë©ë‹ˆë‹¤</p>
                    <button onclick="startAllAnimation()" id="btn-start-all" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-1.5 rounded-lg text-sm font-bold shadow transition">
                        <i class="fa-solid fa-rocket mr-1"></i> ì „ì²´ ê²°ê³¼ ê³µê°œ
                    </button>
                </div>
                
                <div class="flex-1 ladder-scroll overflow-auto relative bg-gray-50 rounded-xl border border-gray-200 shadow-inner w-full">
                    <canvas id="ladder-canvas"></canvas>
                </div>
            </div>

        </div>
    </div>

    <script>
        // === Global State ===
        let playerCount = 4;
        const MAX_PLAYERS = 11;
        const MIN_PLAYERS = 2;
        
        let players = []; // {name, color, x, finished}
        let bottomResults = []; // {text, isLoser, revealed} - ë°”ë‹¥ì— ë°°ì¹˜ëœ ê²°ê³¼ë“¤
        
        let ladderData = []; 
        let ctx = null;
        let canvas = null;
        
        const COL_WIDTH = 100; 
        const TOP_MARGIN = 60; 
        const BOTTOM_MARGIN = 60; 
        const HORIZONTAL_STEPS = 22; 
        
        const COLORS = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD', 
            '#FF9F43', '#54A0FF', '#5F27CD', '#FF9FF3', '#0ABDE3', '#1DD1A1'
        ];

        function adjustCount(delta) {
            playerCount += delta;
            if (playerCount < MIN_PLAYERS) playerCount = MIN_PLAYERS;
            if (playerCount > MAX_PLAYERS) playerCount = MAX_PLAYERS;
            document.getElementById('player-count-display').textContent = playerCount;
        }

        function goToStep2() {
            document.getElementById('step-1').classList.add('hidden');
            document.getElementById('step-2').classList.remove('hidden');
            document.getElementById('step-2').classList.add('flex');
            generateInputs();
        }

        function generateInputs() {
            const container = document.getElementById('input-container');
            container.innerHTML = '';

            for (let i = 0; i < playerCount; i++) {
                const row = document.createElement('div');
                row.className = 'grid grid-cols-[40px_1fr] gap-3 items-center input-group-move';
                row.style.animationDelay = `${i * 0.05}s`;
                
                row.innerHTML = `
                    <div class="flex justify-center items-center w-8 h-8 rounded-full text-white font-bold shadow-sm" style="background-color: ${COLORS[i]}">
                        ${i + 1}
                    </div>
                    <input type="text" id="name-${i}" placeholder="ì°¸ê°€ì ${i+1}" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-400 outline-none" value="ì°¸ê°€ì ${i+1}">
                `;
                container.appendChild(row);
            }
        }

        function fillRandomNames() {
            const randomNames = ["ì² ìˆ˜", "ì˜í¬", "ë¯¼ìˆ˜", "ì§€í˜œ", "ë™í˜„", "ìˆ˜ì§„", "ì¬ìš°", "ë‚˜ì˜", "ì¤€í˜¸", "ìœ ë¦¬", "ì„±ë¯¼"];
            for (let i = 0; i < playerCount; i++) {
                const nameInput = document.getElementById(`name-${i}`);
                if(nameInput) {
                    nameInput.value = randomNames[i % randomNames.length];
                }
            }
        }

        function startGame() {
            // 1. í”Œë ˆì´ì–´ ì •ë³´ ìˆ˜ì§‘
            players = [];
            for (let i = 0; i < playerCount; i++) {
                const name = document.getElementById(`name-${i}`).value || `ì°¸ê°€ì ${i+1}`;
                players.push({ name, color: COLORS[i], finished: false });
            }

            // 2. ë°”ë‹¥ ê²°ê³¼ ìƒì„± (2ëª…ë§Œ ë‹¹ì²¨, ë‚˜ë¨¸ì§€ í†µê³¼)
            bottomResults = [];
            let tempResults = [];
            tempResults.push({text: "ğŸ” ì ì‹¬ì˜ê¸°", isLoser: true});
            tempResults.push({text: "ğŸ” ì ì‹¬ì˜ê¸°", isLoser: true});
            for(let i = 2; i < playerCount; i++) {
                tempResults.push({text: "ğŸ‘ í†µê³¼", isLoser: false});
            }
            
            // ì…”í”Œ
            for (let i = tempResults.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tempResults[i], tempResults[j]] = [tempResults[j], tempResults[i]];
            }

            // ìƒíƒœ ì´ˆê¸°í™”
            bottomResults = tempResults.map(r => ({
                ...r,
                revealed: false // ì²˜ìŒì—ëŠ” ìˆ¨ê¹€
            }));

            // 3. ì‚¬ë‹¤ë¦¬ ìƒì„±
            generateLadderData();

            // 4. í™”ë©´ ì „í™˜
            document.getElementById('step-2').classList.add('hidden');
            document.getElementById('step-2').classList.remove('flex');
            document.getElementById('step-3').classList.remove('hidden');
            document.getElementById('step-3').classList.add('flex');

            setTimeout(initCanvas, 50);
        }

        function generateLadderData() {
            ladderData = []; 
            for (let s = 0; s < HORIZONTAL_STEPS; s++) {
                const stepRow = [];
                for (let c = 0; c < playerCount - 1; c++) {
                    let hasBridge = false;
                    if (Math.random() < 0.5) {
                        if (c === 0 || !stepRow[c-1]) {
                            hasBridge = true;
                        }
                    }
                    stepRow.push(hasBridge);
                }
                ladderData.push(stepRow);
            }
        }

        function initCanvas() {
            canvas = document.getElementById('ladder-canvas');
            ctx = canvas.getContext('2d');
            const scrollContainer = document.querySelector('.ladder-scroll');
            
            const minWidth = scrollContainer.clientWidth;
            const requiredWidth = playerCount * COL_WIDTH + COL_WIDTH;
            const width = Math.max(minWidth, requiredWidth);
            const height = Math.max(scrollContainer.clientHeight, 600); 

            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            ctx.scale(dpr, dpr);

            canvas.removeEventListener('click', handleCanvasClick);
            canvas.addEventListener('click', handleCanvasClick);

            drawBaseLadder();
        }

        function drawBaseLadder() {
            const w = parseInt(canvas.style.width);
            const h = parseInt(canvas.style.height);
            
            ctx.clearRect(0, 0, w, h);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const ladderHeight = h - TOP_MARGIN - BOTTOM_MARGIN;
            const stepHeight = ladderHeight / (HORIZONTAL_STEPS + 1);

            ctx.textAlign = 'center';
            ctx.font = 'bold 14px "Noto Sans KR"';

            for (let i = 0; i < playerCount; i++) {
                const x = (i + 1) * COL_WIDTH;
                
                // ì„¸ë¡œì„ 
                ctx.beginPath();
                ctx.moveTo(x, TOP_MARGIN);
                ctx.lineTo(x, h - BOTTOM_MARGIN);
                ctx.strokeStyle = '#e5e7eb'; // ë” ì—°í•œ ìƒ‰
                ctx.lineWidth = 6;
                ctx.stroke();

                // ìƒë‹¨ ì´ë¦„
                ctx.fillStyle = players[i].color;
                roundRect(ctx, x - 40, 10, 80, 30, 8, true, false);
                ctx.fillStyle = 'white';
                ctx.fillText(players[i].name, x, 30);

                // í•˜ë‹¨ ê²°ê³¼ (ë¯¸ìŠ¤í„°ë¦¬ ìƒì ë¡œì§)
                const resultObj = bottomResults[i];
                
                if (resultObj.revealed) {
                    // ê³µê°œë¨
                    ctx.fillStyle = resultObj.isLoser ? '#ef4444' : '#3b82f6'; // ì˜ê¸°ëŠ” ë¹¨ê°•, í†µê³¼ëŠ” íŒŒë‘
                    roundRect(ctx, x - 45, h - 45, 90, 30, 8, true, false);
                    ctx.fillStyle = 'white';
                    ctx.fillText(resultObj.text, x, h - 25);
                } else {
                    // ìˆ¨ê²¨ì§ (?)
                    ctx.fillStyle = '#9ca3af'; // íšŒìƒ‰
                    roundRect(ctx, x - 30, h - 45, 60, 30, 8, true, false);
                    ctx.fillStyle = 'white';
                    ctx.fillText("?", x, h - 25);
                }
            }

            // ê°€ë¡œì„ 
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 6;

            for (let s = 0; s < HORIZONTAL_STEPS; s++) {
                const y = TOP_MARGIN + (s + 1) * stepHeight;
                for (let c = 0; c < playerCount - 1; c++) {
                    if (ladderData[s][c]) {
                        const x1 = (c + 1) * COL_WIDTH;
                        const x2 = (c + 2) * COL_WIDTH;
                        ctx.beginPath();
                        ctx.moveTo(x1, y);
                        ctx.lineTo(x2, y);
                        ctx.stroke();
                    }
                }
            }
        }

        // === Animation Logic ===
        let animations = [];
        let isAnimating = false;

        function startAllAnimation() {
            if (isAnimating) return;
            document.getElementById('btn-start-all').disabled = true;
            document.getElementById('btn-start-all').classList.add('opacity-50', 'cursor-not-allowed');

            players.forEach((_, idx) => {
                if (!players[idx].finished) { // ì•ˆ ëë‚œ ì‚¬ëŒë§Œ ì¶œë°œ
                    startPlayerAnimation(idx);
                }
            });
        }

        function handleCanvasClick(e) {
            if (isAnimating) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left);
            const y = (e.clientY - rect.top);

            if (y < TOP_MARGIN + 20) {
                const clickedIdx = Math.round((x / COL_WIDTH) - 1);
                if (clickedIdx >= 0 && clickedIdx < playerCount) {
                    const targetX = (clickedIdx + 1) * COL_WIDTH;
                    if (Math.abs(x - targetX) < 40) {
                        if (!players[clickedIdx].finished) {
                            startPlayerAnimation(clickedIdx);
                        }
                    }
                }
            }
        }

        function startPlayerAnimation(playerIndex) {
            const path = calculatePath(playerIndex);
            
            animations.push({
                playerIndex: playerIndex,
                path: path,
                currentStep: 0,
                progress: 0,
                color: players[playerIndex].color
            });

            if (!isAnimating) {
                isAnimating = true;
                animateFrame();
            }
        }

        function calculatePath(startIdx) {
            const path = [];
            const h = parseInt(canvas.style.height);
            const ladderHeight = h - TOP_MARGIN - BOTTOM_MARGIN;
            const stepHeight = ladderHeight / (HORIZONTAL_STEPS + 1);

            let currentX = (startIdx + 1) * COL_WIDTH;
            let currentY = TOP_MARGIN;
            let col = startIdx;

            path.push({x: currentX, y: currentY});

            for (let s = 0; s < HORIZONTAL_STEPS; s++) {
                const nextY = TOP_MARGIN + (s + 1) * stepHeight;
                path.push({x: currentX, y: nextY});
                currentY = nextY;

                if (col < playerCount - 1 && ladderData[s][col]) {
                    currentX += COL_WIDTH;
                    col++;
                    path.push({x: currentX, y: currentY});
                }
                else if (col > 0 && ladderData[s][col-1]) {
                    currentX -= COL_WIDTH;
                    col--;
                    path.push({x: currentX, y: currentY});
                }
            }
            path.push({x: currentX, y: h - BOTTOM_MARGIN});
            return path;
        }

        function animateFrame() {
            if (animations.length === 0) {
                isAnimating = false;
                return;
            }

            drawBaseLadder();
            const speed = 0.25; // ì†ë„

            for (let i = animations.length - 1; i >= 0; i--) {
                const anim = animations[i];
                anim.progress += speed;

                if (anim.progress >= 1) {
                    anim.progress = 0;
                    anim.currentStep++;
                }

                // ê²½ë¡œ ê·¸ë¦¬ê¸°
                ctx.beginPath();
                ctx.strokeStyle = anim.color;
                ctx.lineWidth = 8;
                ctx.moveTo(anim.path[0].x, anim.path[0].y);

                for (let j = 1; j <= anim.currentStep; j++) {
                    if (j < anim.path.length) {
                        ctx.lineTo(anim.path[j].x, anim.path[j].y);
                    }
                }

                if (anim.currentStep < anim.path.length - 1) {
                    const p1 = anim.path[anim.currentStep];
                    const p2 = anim.path[anim.currentStep + 1];
                    const curX = p1.x + (p2.x - p1.x) * anim.progress;
                    const curY = p1.y + (p2.y - p1.y) * anim.progress;
                    ctx.lineTo(curX, curY);
                    
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(curX, curY, 8, 0, Math.PI * 2);
                    ctx.fillStyle = anim.color;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                } else {
                    // ë„ì°©!
                    ctx.stroke();
                    
                    // ì¤‘ìš”: ë„ì°©í•œ ê³³ì˜ ì¸ë±ìŠ¤ ê³„ì‚°í•˜ì—¬ ê²°ê³¼ ê³µê°œ
                    const finalP = anim.path[anim.path.length - 1];
                    const finalColIdx = Math.round((finalP.x / COL_WIDTH) - 1);
                    
                    // ê²°ê³¼ ê³µê°œ ìƒíƒœ ë³€ê²½
                    if (bottomResults[finalColIdx]) {
                        bottomResults[finalColIdx].revealed = true;
                    }

                    // ë„ì°© í›„ ì¦‰ì‹œ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (ê²°ê³¼ í…ìŠ¤íŠ¸ë¥¼ ë³´ì—¬ì£¼ê¸° ìœ„í•´)
                    const resultObj = bottomResults[finalColIdx];
                    const boxColor = resultObj.isLoser ? '#ef4444' : '#3b82f6';

                    ctx.fillStyle = boxColor;
                    roundRect(ctx, finalP.x - 45, parseInt(canvas.style.height) - 45, 90, 30, 8, true, false);
                    ctx.fillStyle = 'white';
                    ctx.fillText(resultObj.text, finalP.x, parseInt(canvas.style.height) - 25);

                    if (!players[anim.playerIndex].finished) {
                        players[anim.playerIndex].finished = true;
                        players[anim.playerIndex].finalPath = anim.path;
                    }
                    animations.splice(i, 1);
                }
            }

            // ì™„ë£Œëœ ê²½ë¡œ ë§ê·¸ë¦¬ê¸°
            players.forEach(p => {
                if (p.finished && p.finalPath) {
                    ctx.beginPath();
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 8;
                    ctx.moveTo(p.finalPath[0].x, p.finalPath[0].y);
                    for (let k = 1; k < p.finalPath.length; k++) {
                        ctx.lineTo(p.finalPath[k].x, p.finalPath[k].y);
                    }
                    ctx.stroke();
                    
                    // ê²°ê³¼ ë°•ìŠ¤ ìœ ì§€ (ì´ë¯¸ drawBaseLadderì—ì„œ ì²˜ë¦¬ë˜ì§€ë§Œ ìµœìƒë‹¨ ë Œë”ë§ì„ ìœ„í•´)
                }
            });

            if (animations.length > 0) {
                requestAnimationFrame(animateFrame);
            } else {
                isAnimating = false;
            }
        }

        function resetGame() {
            players = [];
            animations = [];
            isAnimating = false;
            document.getElementById('btn-start-all').disabled = false;
            document.getElementById('btn-start-all').classList.remove('opacity-50', 'cursor-not-allowed');
            
            document.getElementById('step-3').classList.add('hidden');
            document.getElementById('step-3').classList.remove('flex');
            document.getElementById('step-1').classList.remove('hidden');
        }

        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke === 'undefined') { stroke = true; }
            if (typeof radius === 'undefined') { radius = 5; }
            if (typeof radius === 'number') { radius = {tl: radius, tr: radius, br: radius, bl: radius}; } else { var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0}; for (var side in defaultRadius) { radius[side] = radius[side] || defaultRadius[side]; } }
            ctx.beginPath();
            ctx.moveTo(x + radius.tl, y);
            ctx.lineTo(x + width - radius.tr, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
            ctx.lineTo(x + width, y + height - radius.br);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
            ctx.lineTo(x + radius.bl, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
            ctx.lineTo(x, y + radius.tl);
            ctx.quadraticCurveTo(x, y, x + radius.tl, y);
            ctx.closePath();
            if (fill) { ctx.fill(); }
            if (stroke) { ctx.stroke(); }
        }

        adjustCount(0);

    </script>
</body>
</html>
